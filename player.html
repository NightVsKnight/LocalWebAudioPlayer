<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Local MP3 Folder Player</title>
<style>
  :root {
    --bg: #040712;
    --panel: rgba(9, 16, 38, 0.78);
    --panel-strong: rgba(13, 20, 48, 0.92);
    --accent: #5dfbff;
    --muted: #8da0d8;
    --text: #f3f8ff;
    --border: rgba(108, 154, 255, 0.22);
    --glow: rgba(93, 251, 255, 0.45);
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color: var(--text); background-color: var(--bg);
    min-height: 100dvh; display: grid; place-items: center; padding: 20px;
    position: relative; overflow: hidden;
  }
  body::before,
  body::after {
    content: ''; position: fixed; inset: -140px;
    pointer-events: none; z-index: -2;
  }
  body::before {
    background:
      radial-gradient(420px 380px at 20% 25%, rgba(89, 32, 188, 0.42), transparent 70%),
      radial-gradient(360px 340px at 78% 18%, rgba(10, 132, 255, 0.34), transparent 65%),
      radial-gradient(520px 460px at 50% 86%, rgba(220, 46, 210, 0.24), transparent 75%);
    filter: blur(10px);
    animation: nebulaShift 18s ease-in-out infinite alternate;
  }
  body::after {
    z-index: -1; opacity: 0.65;
    background-image:
      radial-gradient(1px 1px at 20px 30px, rgba(255,255,255,0.85), transparent),
      radial-gradient(1px 1px at 80px 120px, rgba(149,205,255,0.9), transparent),
      radial-gradient(1px 1px at 160px 90px, rgba(255,255,255,0.7), transparent),
      radial-gradient(2px 2px at 60px 200px, rgba(255,255,255,0.8), transparent),
      radial-gradient(1px 1px at 200px 40px, rgba(255,255,255,0.6), transparent);
    background-size: 260px 260px, 320px 320px, 280px 280px, 360px 360px, 400px 400px;
    animation: starDrift 60s linear infinite;
  }
  .app {
    width: min(980px, 100%); background: linear-gradient(150deg, var(--panel), var(--panel-strong));
    border: 1px solid var(--border); border-radius: 20px; box-shadow: 0 20px 60px rgba(2, 8, 23, 0.65), 0 0 38px rgba(93, 251, 255, 0.15);
    overflow: hidden;
    backdrop-filter: blur(16px);
  }
  header {
    display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 16px 18px 10px;
    border-bottom: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(9,16,38,0.12));
    box-shadow: inset 0 -1px 0 rgba(93, 251, 255, 0.08);
  }
  h1 { margin: 0; font-size: 19px; letter-spacing: .38px; font-weight: 600; text-shadow: 0 0 14px rgba(93, 251, 255, 0.45); }
  .hint { color: var(--muted); font-size: 12px; }
  .folder-path {
    margin-top: 4px; font-size: 12px; color: var(--accent); overflow-wrap: anywhere; text-shadow: 0 0 10px rgba(93, 251, 255, 0.4);
  }
  .choose { appearance: none; border: 1px solid var(--border); background: #101427; color: var(--text);
    padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 600; letter-spacing: .3px;
    box-shadow: 0 0 20px rgba(93, 251, 255, 0.12); transition: border-color .2s ease, box-shadow .2s ease, transform .2s ease;
  }
  .choose:hover { border-color: rgba(93, 251, 255, 0.45); box-shadow: 0 0 24px rgba(93, 251, 255, 0.28); transform: translateY(-1px); }
  .wrap {
    display: grid; grid-template-columns: 1.1fr .9fr; gap: 0; min-height: 460px;
  }
  @media (max-width: 900px) { .wrap { grid-template-columns: 1fr; } }
  .player {
    padding: 18px; display: grid; grid-template-rows: auto auto 1fr; gap: 14px; border-right: 1px solid var(--border);
    background: linear-gradient(180deg, rgba(13, 20, 48, 0.46), transparent);
  }
  @media (max-width: 900px) { .player { border-right: none; border-bottom: 1px solid var(--border); } }
  .now {
    background: rgba(11, 18, 46, 0.84); border: 1px solid var(--border); border-radius: 14px; padding: 14px;
    box-shadow: 0 0 22px rgba(93, 251, 255, 0.08);
  }
  .now small { color: var(--muted); display: block; margin-bottom: 6px; }
  .now strong { display: block; font-size: 16px; line-height: 1.3; }
  .controls {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;
  }
  button.ctrl {
    border: 1px solid var(--border); background: rgba(12, 19, 44, 0.82); color: var(--text);
    padding: 12px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    box-shadow: 0 0 18px rgba(93, 251, 255, 0.08); transition: border-color .2s ease, box-shadow .2s ease, transform .2s ease;
  }
  button.ctrl[aria-pressed="true"], button.ctrl.active {
    outline: 2px solid color-mix(in oklab, var(--accent) 70%, transparent); box-shadow: 0 0 24px rgba(93, 251, 255, 0.35);
  }
  button.ctrl:hover { border-color: rgba(93, 251, 255, 0.45); box-shadow: 0 0 26px rgba(93, 251, 255, 0.45); transform: translateY(-1px); }
  .seek {
    display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px; margin-top: 4px;
  }
  input[type="range"] {
    width: 100%; accent-color: var(--accent);
    background: linear-gradient(90deg, rgba(93, 251, 255, 0.45), rgba(155, 132, 255, 0.35));
    border-radius: 999px; height: 4px;
  }
  .time { color: var(--muted); min-width: 108px; text-align: right; font-variant-numeric: tabular-nums; }
  .list {
    padding: 12px; overflow: auto; max-height: 560px;
    background: linear-gradient(180deg, rgba(8, 14, 36, 0.55), rgba(8, 14, 36, 0.2));
  }
  .item {
    display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 10px;
    padding: 10px 12px; border-radius: 12px; cursor: pointer; user-select: none;
    transition: background-color .18s ease, box-shadow .18s ease, transform .18s ease;
  }
  .item:hover { background: rgba(93, 251, 255, 0.08); box-shadow: 0 10px 28px rgba(2, 8, 23, 0.4); transform: translateX(2px); }
  .item.active { background: rgba(93, 251, 255, 0.16); outline: 1px solid rgba(93, 251, 255, 0.45); box-shadow: 0 0 24px rgba(93, 251, 255, 0.25); }
  .num { color: var(--muted); width: 2ch; text-align: right; text-shadow: 0 0 6px rgba(93, 251, 255, 0.35); }
  .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .dur { color: var(--muted); font-variant-numeric: tabular-nums; }
  footer {
    padding: 10px 18px 14px; display: flex; align-items: center; justify-content: space-between;
    border-top: 1px solid var(--border); color: var(--muted); font-size: 12px;
    background: linear-gradient(0deg, rgba(9, 16, 38, 0.18), transparent);
  }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#0e1327; border:1px solid var(--border);
    padding: 2px 6px; border-radius: 6px; color: var(--text); box-shadow: 0 0 12px rgba(93, 251, 255, 0.12);
  }
  .hide { display: none !important; }
  .tree-root { margin-top: 4px; }
  details.tree-dir { padding-left: 0; margin: 2px 0 2px; }
  details.tree-dir > summary {
    cursor: pointer; padding: 6px 10px; border-radius: 8px;
    list-style: none; display: flex; align-items: center; gap: 8px;
    color: var(--muted); background: transparent;
  }
  details.tree-dir > summary::before {
    content: '📁'; font-size: 14px;
  }
  details.tree-dir > summary::-webkit-details-marker { display: none; }
  details.tree-dir[open] > summary { color: var(--text); background: rgba(93, 251, 255, 0.08); }
  details.tree-dir > summary:hover { background: rgba(93, 251, 255, 0.1); color: var(--text); }
  .tree-children { margin-left: 18px; border-left: 1px solid rgba(93, 251, 255, 0.2); padding-left: 10px; }
  .tree-children .item { margin: 2px 0; }
  .tree-children .num { min-width: 2.5ch; color: var(--muted); text-align: right; text-shadow: 0 0 6px rgba(93, 251, 255, 0.35); }
  .track-item { margin: 2px 0; }
  @keyframes nebulaShift {
    0% { transform: translate3d(-2%, -1%, 0) scale(1.02); }
    50% { transform: translate3d(1%, 2%, 0) scale(1.06); }
    100% { transform: translate3d(3%, -2%, 0) scale(1.03); }
  }
  @keyframes starDrift {
    0% { transform: translate3d(0, 0, 0); }
    100% { transform: translate3d(-240px, -360px, 0); }
  }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Local MP3 Folder Player">
    <header>
      <div>
        <h1>Local MP3 Folder Player</h1>
        <div class="hint">Choose a folder to scan recursively for <strong>.mp3</strong> files (Chromium browsers).</div>
        <div class="folder-path" id="folderPath" aria-live="polite">No folder selected.</div>
      </div>
      <button class="choose" id="chooseBtn">🎵 Choose folder…</button>
    </header>

    <div class="wrap">
      <section class="player">
        <div class="now">
          <small>Now Playing</small>
          <strong id="nowTitle">—</strong>
        </div>

        <div class="controls" role="group" aria-label="Playback controls">
          <button class="ctrl" id="prevBtn" title="Previous (←)">⏮ Prev</button>
          <button class="ctrl" id="playPauseBtn" title="Space">▶️ Play</button>
          <button class="ctrl" id="nextBtn" title="Next (→)">⏭ Next</button>
          <button class="ctrl" id="shuffleBtn" aria-pressed="true" title="Toggle Shuffle (S)">🔀 Shuffle</button>
          <button class="ctrl" id="loopBtn" title="Cycle Loop (L)">🔁 Loop: All</button>
          <button class="ctrl" id="announceBtn" aria-pressed="true" title="Toggle Speech Announcements (A)">🗣 Announce On</button>
        </div>

        <div class="seek">
          <input id="seek" type="range" min="0" max="1000" value="0" />
          <div class="time"><span id="tCur">0:00</span> / <span id="tTot">0:00</span></div>
        </div>
      </section>

      <aside class="list" id="list" aria-label="Playlist"></aside>
    </div>

    <footer>
      <div>Shortcuts: <span class="kbd">Space</span> Play/Pause · <span class="kbd">←/→</span> Prev/Next · <span class="kbd">S</span> Shuffle · <span class="kbd">L</span> Loop · <span class="kbd">A</span> Announce</div>
      <div id="count">0 tracks</div>
    </footer>
  </div>

  <audio id="audio" class="hide" preload="metadata"></audio>

<script>
(() => {
  const chooseBtn   = document.getElementById('chooseBtn');
  const listEl      = document.getElementById('list');
  const audio       = document.getElementById('audio');
  const nowTitleEl  = document.getElementById('nowTitle');
  const countEl     = document.getElementById('count');

  const prevBtn     = document.getElementById('prevBtn');
  const playPauseBtn= document.getElementById('playPauseBtn');
  const nextBtn     = document.getElementById('nextBtn');
  const shuffleBtn  = document.getElementById('shuffleBtn');
  const loopBtn     = document.getElementById('loopBtn');
  const announceBtn = document.getElementById('announceBtn');

  const seek        = document.getElementById('seek');
  const tCur        = document.getElementById('tCur');
  const tTot        = document.getElementById('tTot');
  const folderPathEl= document.getElementById('folderPath');

  /** Persistence */
  const DB_NAME = 'lwa-player';
  const STORE_NAME = 'handles';
  const LAST_KEY = 'last-folder';
  const SHUFFLE_KEY = 'shuffle-enabled';
  const LOOP_KEY = 'loop-mode';
  const LAST_TRACK_KEY = 'last-track';
  const ANNOUNCE_KEY = 'lwa-announce-enabled';
  let handleDbPromise = null;
  const NAME_COLLATOR = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });

  const getHandleDb = () => {
    if (!('indexedDB' in window)) return null;
    if (!handleDbPromise) {
      handleDbPromise = new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onerror = () => reject(req.error);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
        };
        req.onsuccess = () => resolve(req.result);
      }).catch(err => {
        console.error('Failed opening handle DB', err);
        handleDbPromise = null;
        return null;
      });
    }
    return handleDbPromise;
  };

  const putStoreValue = async (key, value) => {
    const db = await getHandleDb();
    if (!db) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      tx.objectStore(STORE_NAME).put(value, key);
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });
  };

  const getStoreValue = async (key) => {
    const db = await getHandleDb();
    if (!db) return undefined;
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const req = tx.objectStore(STORE_NAME).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  };

  const saveLastHandle = async (handle) => {
    try {
      await putStoreValue(LAST_KEY, handle);
    } catch (err) {
      console.error('Failed storing folder handle', err);
    }
  };

  const loadLastHandle = async () => {
    try {
      const handle = await getStoreValue(LAST_KEY);
      return handle ?? null;
    } catch (err) {
      console.error('Failed loading folder handle', err);
      return null;
    }
  };

  const setFolderPath = (handle, { loading = false } = {}) => {
    if (!folderPathEl) return;
    if (!handle) {
      folderPathEl.textContent = 'No folder selected.';
      return;
    }
    const name = handle.name || 'Unknown folder';
    folderPathEl.textContent = loading ? `Folder: ${name} (loading...)` : `Folder: ${name}`;
  };

  /** Playlist state */
  let tracks = [];           // {name, displayName, handle, url, duration, path}
  let current = -1;
  let shuffle = true;        // toggle
  let loopMode = 'all';      // 'all' | 'one' | 'off'
  let trackRefs = new Map(); // index -> {row, durEl, ancestors}
  let rootDirName = '';
  const trackKey = (track) => [...track.path, track.name].join('/');
  const speech = createSpeechSynth();
  let announceEnabled = speech.supported;
  let pendingAnnouncement = null;
  let lastAnnouncedTitle = null;
  let lastAnnouncedTrackKey = null;

  /** Utilities */
  const fmtTime = s => {
    if (!isFinite(s) || s < 0) s = 0;
    const m = Math.floor(s / 60), ss = Math.floor(s % 60);
    return `${m}:${ss.toString().padStart(2,'0')}`;
  };
  // Converts filenames such as "01 Artist - Title" into a speech-friendly "Title, by Artist".
  const formatAnnouncementTitle = (name) => {
    if (!name) return 'Unknown track';
    const cleaned = name.replace(/[_]+/g, ' ').replace(/\s+/g, ' ').trim();
    if (!cleaned) return 'Unknown track';
    const normalized = cleaned.replace(/[–—]/g, '-');
    const parts = normalized.split(' - ');
    if (parts.length >= 2) {
      const artistRaw = parts[0].replace(/^\d+\s*/, '').trim().replace(/\s+/g, ' ');
      const titleRaw = parts.slice(1).join(' - ').trim().replace(/\s+/g, ' ');
      if (artistRaw && titleRaw) {
        return `${titleRaw}, by ${artistRaw}`;
      }
    }
    return cleaned;
  };

  const recordPendingAnnouncement = (track) => {
    if (!track) {
      pendingAnnouncement = null;
      return;
    }
    pendingAnnouncement = {
      key: trackKey(track),
      title: formatAnnouncementTitle(track.displayName),
    };
  };

  const maybeAnnounceCurrentTrack = () => {
    if (!pendingAnnouncement) return;
    const { key, title } = pendingAnnouncement;
    pendingAnnouncement = null;
    if (!title) return;

    // Announcements are disabled by the user.
    if (!announceEnabled) return;
    // Speech synthesis is not available in this browser.
    if (!speech.supported) return;
    // Avoid repeating the same announcement if the track restarts.
    if (key === lastAnnouncedTrackKey) return;

    let message = '';
    if (lastAnnouncedTitle && lastAnnouncedTitle !== title) {
      message = `That was ${lastAnnouncedTitle}. `;
    }
    message += `Now playing: ${title}`;
    speech.speak(message, { interrupt: true });
    lastAnnouncedTitle = title;
    lastAnnouncedTrackKey = key;
  };

  const readAnnouncePreference = () => {
    try {
      const stored = localStorage.getItem(ANNOUNCE_KEY);
      if (stored === null) return true;
      return stored === '1';
    } catch (err) {
      console.warn('Unable to read announce preference', err);
      return true;
    }
  };

  const setAnnounceEnabled = (value, { persist = true } = {}) => {
    const effective = Boolean(value && speech.supported);
    announceEnabled = effective;
    if (announceBtn) {
      announceBtn.setAttribute('aria-pressed', String(effective));
      announceBtn.classList.toggle('active', effective);
      announceBtn.textContent = effective ? '🗣 Announce On' : '🤫 Announce Off';
    }
    if (persist && speech.supported) {
      try { localStorage.setItem(ANNOUNCE_KEY, effective ? '1' : '0'); }
      catch (err) { console.warn('Unable to store announce preference', err); }
    }
    if (!effective) {
      speech.cancel();
    } else if (audio && !audio.paused && current >= 0 && tracks[current]) {
      // Allow a fresh announcement when the toggle is re-enabled mid-track.
      lastAnnouncedTrackKey = null;
      recordPendingAnnouncement(tracks[current]);
      maybeAnnounceCurrentTrack();
    }
  };

  function createSpeechSynth() {
    const synth = window.speechSynthesis;
    if (!(synth && 'SpeechSynthesisUtterance' in window)) {
      console.warn('Speech synthesis not supported in this browser');
      return {
        supported: false,
        speak: () => {},
        cancel: () => {},
      };
    }

    // Prefer Daniel for consistent pacing; fall back to any English voice, then any remaining option.
    const PREFERRED_VOICE_NAMES = [
      'Daniel (English (United Kingdom))',
      'Daniel (English (United States))',
      'Daniel',
    ];
    let voice = null;
    let queued = null;
    let awaitingVoices = false;

    function pickVoice() {
      const voices = synth.getVoices();
      if (!voices.length) return null;
      voice = voices.find(v => PREFERRED_VOICE_NAMES.includes(v.name))
        || voices.find(v => v.lang && v.lang.toLowerCase().startsWith('en') && v.localService)
        || voices.find(v => v.lang && v.lang.toLowerCase().startsWith('en'))
        || voices[0];
      return voice;
    }

    function handleVoicesChanged() {
      if (voice) return;
      if (!pickVoice()) return;
      synth.removeEventListener('voiceschanged', handleVoicesChanged);
      awaitingVoices = false;
      if (queued) {
        const { text, opts } = queued;
        queued = null;
        speak(text, opts);
      }
    }

    function ensureVoice() {
      if (voice) return true;
      if (pickVoice()) return true;
      if (!awaitingVoices) {
        awaitingVoices = true;
        synth.addEventListener('voiceschanged', handleVoicesChanged);
      }
      return false;
    }

    function speak(text, opts = {}) {
      if (!text) return;
      if (!ensureVoice()) {
        queued = { text, opts };
        return;
      }
      const shouldInterrupt = opts.interrupt ?? true;
      if (shouldInterrupt) synth.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      if (voice) {
        utter.voice = voice;
        utter.lang = voice.lang;
      }
      utter.volume = opts.volume ?? 1;
      utter.rate = opts.rate ?? 1;
      utter.pitch = opts.pitch ?? 1;
      synth.speak(utter);
    }

    function cancel() {
      synth.cancel();
      queued = null;
    }

    return { supported: true, speak, cancel };
  }

  const revokeAll = () => {
    tracks.forEach(t => { if (t.url) URL.revokeObjectURL(t.url); });
  };

  async function* walk(dir, path = []) {
    for await (const [name, handle] of dir.entries()) {
      if (handle.kind === 'file') {
        if (name.toLowerCase().endsWith('.mp3')) {
          yield { name, handle, path };
        }
      } else if (handle.kind === 'directory') {
        if (!name.startsWith('.')) {
          yield* walk(handle, [...path, name]);
        }
      }
    }
  }

  async function scanFolder(dirHandle) {
    setFolderPath(dirHandle, { loading: true });
    rootDirName = dirHandle?.name || 'Selected Folder';
    tracks = [];
    current = -1;
    pendingAnnouncement = null;
    lastAnnouncedTitle = null;
    lastAnnouncedTrackKey = null;
    revokeAll();
    listEl.innerHTML = '';
    nowTitleEl.textContent = '—';
    countEl.textContent = 'Scanning…';

    try {
      for await (const entry of walk(dirHandle)) {
        const { handle: fh, path } = entry;
        const file = await fh.getFile();
        const url = URL.createObjectURL(file);
        tracks.push({
          name: file.name,
          displayName: file.name.replace(/\.mp3$/i, ''),
          handle: fh,
          url,
          duration: NaN,
          path: [...path],
        });
      }
    } catch (err) {
      console.error('Failed scanning folder', err);
      tracks = [];
    }

    tracks.sort((a, b) => NAME_COLLATOR.compare(trackKey(a), trackKey(b)));

    renderList();
    countEl.textContent = `${tracks.length} track${tracks.length===1?'':'s'}`;
    if (tracks.length) {
      let targetIdx = 0;
      try {
        const storedKey = await getStoreValue(LAST_TRACK_KEY);
        if (typeof storedKey === 'string') {
          const found = tracks.findIndex(t => trackKey(t) === storedKey);
          if (found >= 0) {
            targetIdx = found;
          } else if (shuffle && tracks.length > 1) {
            targetIdx = Math.floor(Math.random() * tracks.length);
            console.info('Last known track missing; selecting a random track because shuffle is on.');
          } else {
            console.info('Last known track not found; defaulting to first track.');
          }
        }
      } catch (err) {
        console.error('Failed loading last track', err);
      }
      playIndex(targetIdx, {autoplay:false});
    }
    setFolderPath(dirHandle);
  }

  if (announceBtn) {
    if (speech.supported) {
      const initial = readAnnouncePreference();
      setAnnounceEnabled(initial, { persist: false });
      announceBtn.addEventListener('click', () => setAnnounceEnabled(!announceEnabled));
    } else {
      announceBtn.textContent = '🚫 Announce Unavailable';
      announceBtn.disabled = true;
      announceBtn.title = 'Speech synthesis not supported in this browser.';
      announceBtn.setAttribute('aria-disabled', 'true');
      announceBtn.setAttribute('aria-pressed', 'false');
      announceBtn.classList.remove('active');
    }
  }

  function renderList() {
    trackRefs = new Map();
    listEl.innerHTML = '';
    if (!tracks.length) {
      highlightActive();
      return;
    }

    const tree = buildTrackTree();
    const wrapper = document.createElement('div');
    wrapper.className = 'tree-root';

    const topDirs = Array.from(tree.dirs.values()).sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    topDirs.forEach(dir => wrapper.appendChild(renderDirNode(dir, 0, [])));

    const rootFiles = tree.files.slice().sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    rootFiles.forEach(file => wrapper.appendChild(renderTrackLeaf(file.index, [])));

    listEl.appendChild(wrapper);
    highlightActive();
  }

  function buildTrackTree() {
    const root = { name: rootDirName, dirs: new Map(), files: [] };
    tracks.forEach((track, index) => {
      let node = root;
      track.path.forEach(segment => {
        if (!node.dirs.has(segment)) {
          node.dirs.set(segment, { name: segment, dirs: new Map(), files: [] });
        }
        node = node.dirs.get(segment);
      });
      node.files.push({ name: track.name, index });
    });
    return root;
  }

  function renderDirNode(node, depth, ancestors) {
    const details = document.createElement('details');
    details.className = 'tree-dir';
    if (depth < 1) details.open = true;

    const summary = document.createElement('summary');
    summary.textContent = node.name;
    details.appendChild(summary);

    const children = document.createElement('div');
    children.className = 'tree-children';
    const nextAncestors = ancestors.concat(details);

    const subDirs = Array.from(node.dirs.values()).sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    subDirs.forEach(child => children.appendChild(renderDirNode(child, depth + 1, nextAncestors)));

    const files = node.files.slice().sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    files.forEach(file => children.appendChild(renderTrackLeaf(file.index, nextAncestors)));

    if (children.children.length) details.appendChild(children);
    return details;
  }

  function renderTrackLeaf(index, ancestors) {
    const track = tracks[index];
    const row = document.createElement('div');
    row.className = 'item track-item';
    row.dataset.index = index;
    row.role = 'button';
    row.tabIndex = 0;
    const relative = track.path.length ? `${track.path.join('/')}/${track.name}` : track.name;
    row.title = relative;

    const icon = document.createElement('div');
    icon.className = 'num';
    icon.textContent = index + 1;

    const nameEl = document.createElement('div');
    nameEl.className = 'name';
    nameEl.textContent = track.displayName;

    const durEl = document.createElement('div');
    durEl.className = 'dur';
    durEl.textContent = isFinite(track.duration) ? fmtTime(track.duration) : '';

    row.append(icon, nameEl, durEl);
    row.addEventListener('click', () => playIndex(index, {autoplay:true}));
    row.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        playIndex(index, {autoplay:true});
      }
    });

    trackRefs.set(index, { row, durEl, ancestors });
    if (!isFinite(track.duration)) {
      primeDuration(index, durEl);
    }

    return row;
  }

  function primeDuration(index, durEl) {
    const track = tracks[index];
    const tmp = new Audio();
    tmp.preload = 'metadata';
    tmp.src = track.url;
    const clearTmp = () => {
      tmp.src = '';
      try { tmp.load(); } catch (_) {}
    };
    tmp.addEventListener('loadedmetadata', () => {
      track.duration = tmp.duration;
      if (durEl.isConnected) {
        durEl.textContent = isFinite(track.duration) ? fmtTime(track.duration) : '';
      }
      clearTmp();
    }, {once:true});
    tmp.addEventListener('error', clearTmp, {once:true});
  }

  function highlightActive() {
    trackRefs.forEach(ref => ref.row.classList.remove('active'));
    if (current < 0) return;
    const ref = trackRefs.get(current);
    if (!ref) return;
    ref.row.classList.add('active');
    ref.ancestors.forEach(det => {
      if (det && !det.open) det.open = true;
    });
    if (ref.row.isConnected) {
      ref.row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }

  function applyShuffleState() {
    shuffleBtn.setAttribute('aria-pressed', String(shuffle));
    shuffleBtn.classList.toggle('active', shuffle);
  }

  function setLoopLabel() {
    const labels = { all: '🔁 Loop: All', one: '🔂 Loop: One', off: '⏹ Loop: Off' };
    loopBtn.textContent = labels[loopMode];
    audio.loop = (loopMode === 'one');
  }

  async function playIndex(idx, {autoplay=true} = {}) {
    if (!tracks.length) return;
    if (idx < 0) idx = 0;
    if (idx >= tracks.length) idx = tracks.length - 1;
    current = idx;

    const tr = tracks[current];
    recordPendingAnnouncement(tr);
    audio.src = tr.url;
    nowTitleEl.textContent = tr.displayName;
    highlightActive();
    putStoreValue(LAST_TRACK_KEY, trackKey(tr)).catch(err => {
      console.error('Failed storing last track', err);
    });

    // Reset UI time
    seek.value = 0;
    tCur.textContent = '0:00';
    tTot.textContent = isFinite(tr.duration) ? fmtTime(tr.duration) : '0:00';

    if (autoplay) {
      try { await audio.play(); playPauseBtn.textContent = '⏸ Pause'; }
      catch(e){ /* ignore autoplay block */ }
    } else {
      playPauseBtn.textContent = '▶️ Play';
    }
  }

  function nextIndex() {
    if (!tracks.length) return current;
    if (shuffle && tracks.length > 1) {
      // random but avoid immediate repeat
      let idx;
      do { idx = Math.floor(Math.random() * tracks.length); } while (idx === current);
      return idx;
    }
    // linear advance, wrap if loop all, else clamp at end (handled in ended)
    let idx = current + 1;
    if (idx >= tracks.length) idx = 0;
    return idx;
  }

  function prevIndex() {
    if (!tracks.length) return current;
    if (shuffle && tracks.length > 1) {
      let idx;
      do { idx = Math.floor(Math.random() * tracks.length); } while (idx === current);
      return idx;
    }
    let idx = current - 1;
    if (idx < 0) idx = tracks.length - 1;
    return idx;
  }

  const loadPreferences = async () => {
    try {
      const storedShuffle = await getStoreValue(SHUFFLE_KEY);
      if (typeof storedShuffle === 'boolean') shuffle = storedShuffle;
    } catch (err) {
      console.error('Failed loading shuffle preference', err);
    }
    applyShuffleState();

    try {
      const storedLoop = await getStoreValue(LOOP_KEY);
      if (storedLoop === 'all' || storedLoop === 'one' || storedLoop === 'off') {
        loopMode = storedLoop;
      }
    } catch (err) {
      console.error('Failed loading loop preference', err);
    }
    setLoopLabel();
  };

  /** Event wiring */
  applyShuffleState();
  setLoopLabel();
  loadPreferences();

  chooseBtn.addEventListener('click', async () => {
    if (!('showDirectoryPicker' in window)) {
      alert('Your browser does not support picking folders. Use a Chromium-based browser like Chrome or Edge.');
      return;
    }
    try {
      const dir = await window.showDirectoryPicker({ id: 'mp3-player-root' });
      const perm = await dir.requestPermission({ mode: 'read' });
      if (perm === 'granted') {
        await scanFolder(dir);
        await saveLastHandle(dir);
      } else { alert('Read permission was not granted.'); }
    } catch (e) {
      if (e?.name !== 'AbortError') console.error(e);
    }
  });

  playPauseBtn.addEventListener('click', async () => {
    if (!tracks.length) return;
    if (audio.paused) {
      try { await audio.play(); playPauseBtn.textContent = '⏸ Pause'; } catch(e){}
    } else {
      audio.pause(); playPauseBtn.textContent = '▶️ Play';
    }
  });

  nextBtn.addEventListener('click', () => playIndex(nextIndex(), {autoplay:true}));
  prevBtn.addEventListener('click', () => playIndex(prevIndex(), {autoplay:true}));

  shuffleBtn.addEventListener('click', () => {
    shuffle = !shuffle;
    applyShuffleState();
    putStoreValue(SHUFFLE_KEY, shuffle).catch(err => {
      console.error('Failed storing shuffle preference', err);
    });
  });

  loopBtn.addEventListener('click', () => {
    loopMode = loopMode === 'all' ? 'one' : loopMode === 'one' ? 'off' : 'all';
    setLoopLabel();
    putStoreValue(LOOP_KEY, loopMode).catch(err => {
      console.error('Failed storing loop preference', err);
    });
  });

  // Audio timing UI
  audio.addEventListener('loadedmetadata', () => {
    tTot.textContent = fmtTime(audio.duration);
  });
  audio.addEventListener('play', maybeAnnounceCurrentTrack);
  audio.addEventListener('timeupdate', () => {
    if (!isFinite(audio.duration) || audio.duration <= 0) return;
    const pos = Math.round((audio.currentTime / audio.duration) * 1000);
    seek.value = String(pos);
    tCur.textContent = fmtTime(audio.currentTime);
  });
  seek.addEventListener('input', () => {
    if (!isFinite(audio.duration) || audio.duration <= 0) return;
    const pos = Number(seek.value) / 1000;
    audio.currentTime = audio.duration * pos;
  });

  // Track end behavior
  audio.addEventListener('ended', () => {
    // If loop one is set, audio.loop handles it.
    if (loopMode === 'one') return;
    // Loop all or off:
    if (shuffle || loopMode === 'all') {
      playIndex(nextIndex(), {autoplay:true});
    } else {
      // Off: if not last, go next; if last, stop at end.
      if (current < tracks.length - 1) playIndex(current + 1, {autoplay:true});
      else { playPauseBtn.textContent = '▶️ Play'; }
    }
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (['INPUT','TEXTAREA'].includes(e.target.tagName)) return;
    if (e.code === 'Space') { e.preventDefault(); playPauseBtn.click(); }
    else if (e.key === 'ArrowRight') nextBtn.click();
    else if (e.key === 'ArrowLeft') prevBtn.click();
    else if (e.key.toLowerCase() === 's') shuffleBtn.click();
    else if (e.key.toLowerCase() === 'l') loopBtn.click();
    else if (e.key.toLowerCase() === 'a' && announceBtn && !announceBtn.disabled) {
      e.preventDefault();
      announceBtn.click();
    }
  });

  // Clean up object URLs when leaving
  window.addEventListener('beforeunload', revokeAll);

  // Restore previous folder if permission remains granted
  (async () => {
    const last = await loadLastHandle();
    if (!last) return;
    try {
      const perm = await last.queryPermission({ mode: 'read' });
      if (perm === 'granted') {
        await scanFolder(last);
      }
    } catch (err) {
      console.error('Unable to restore previous folder', err);
      setFolderPath(null);
    }
  })();
})();
</script>
</body>
</html>
