<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Local MP3 Folder Player</title>
<style>
  :root {
    --bg: #040712;
    --panel: rgba(9, 16, 38, 0.78);
    --panel-strong: rgba(13, 20, 48, 0.92);
    --accent: #5dfbff;
    --muted: #8da0d8;
    --text: #f3f8ff;
    --border: rgba(108, 154, 255, 0.22);
    --glow: rgba(93, 251, 255, 0.45);
    --ctrl-min: 120px;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color: var(--text); background-color: var(--bg);
    min-height: 100dvh; display: grid; place-items: center; padding: 20px;
    position: relative; overflow: hidden;
  }
  body::before,
  body::after {
    content: ''; position: fixed; inset: -140px;
    pointer-events: none; z-index: -2;
  }
  body::before {
    background:
      radial-gradient(420px 380px at 20% 25%, rgba(89, 32, 188, 0.42), transparent 70%),
      radial-gradient(360px 340px at 78% 18%, rgba(10, 132, 255, 0.34), transparent 65%),
      radial-gradient(520px 460px at 50% 86%, rgba(220, 46, 210, 0.24), transparent 75%);
    filter: blur(10px);
    animation: nebulaShift 18s ease-in-out infinite alternate;
  }
  body::after {
    z-index: -1; opacity: 0.65;
    background-image:
      radial-gradient(1px 1px at 20px 30px, rgba(255,255,255,0.85), transparent),
      radial-gradient(1px 1px at 80px 120px, rgba(149,205,255,0.9), transparent),
      radial-gradient(1px 1px at 160px 90px, rgba(255,255,255,0.7), transparent),
      radial-gradient(2px 2px at 60px 200px, rgba(255,255,255,0.8), transparent),
      radial-gradient(1px 1px at 200px 40px, rgba(255,255,255,0.6), transparent);
    background-size: 260px 260px, 320px 320px, 280px 280px, 360px 360px, 400px 400px;
    animation: starDrift 60s linear infinite;
  }
  .app {
    width: min(980px, 100%); background: linear-gradient(150deg, var(--panel), var(--panel-strong));
    border: 1px solid var(--border); border-radius: 20px; box-shadow: 0 20px 60px rgba(2, 8, 23, 0.65), 0 0 38px rgba(93, 251, 255, 0.15);
    overflow: hidden;
    backdrop-filter: blur(16px);
  }
  header {
    display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 16px 18px 10px;
    border-bottom: 1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(9,16,38,0.12));
    box-shadow: inset 0 -1px 0 rgba(93, 251, 255, 0.08);
  }
  h1 { margin: 0; font-size: 19px; letter-spacing: .38px; font-weight: 600; text-shadow: 0 0 14px rgba(93, 251, 255, 0.45); }
  .hint { color: var(--muted); font-size: 12px; }
  .folder-path {
    margin-top: 4px; font-size: 12px; color: var(--accent); overflow-wrap: anywhere; text-shadow: 0 0 10px rgba(93, 251, 255, 0.4);
  }
  .choose { appearance: none; border: 1px solid var(--border); background: #101427; color: var(--text);
    padding: 10px 14px; border-radius: 12px; cursor: pointer; font-weight: 600; letter-spacing: .3px;
    box-shadow: 0 0 20px rgba(93, 251, 255, 0.12); transition: border-color .2s ease, box-shadow .2s ease, transform .2s ease;
  }
  .choose:hover { border-color: rgba(93, 251, 255, 0.45); box-shadow: 0 0 24px rgba(93, 251, 255, 0.28); transform: translateY(-1px); }
  .wrap {
    /* Left: main player (will have an internal 4-col grid), Right: playlist */
    display: grid; grid-template-columns: 1fr 320px; gap: 0; min-height: 520px;
  }
  @media (max-width: 1100px) { .wrap { grid-template-columns: 1fr 260px; } }
  @media (max-width: 900px) { .wrap { grid-template-columns: 1fr; } }

  .player {
    padding-top: 18px;
    padding-left: 18px;
    padding-bottom: 18px;
    padding-right: 0px;
    display: grid;
    /* internal player grid: 3 main columns + 1 auto column for the volume panel
      Use `auto` so the volume column only becomes as wide as its contents. */
    grid-template-columns: 1fr 1fr 1fr auto;
    grid-auto-rows: auto; gap: 14px; 
    background: linear-gradient(180deg, rgba(13, 20, 48, 0.46), transparent);
  }
  @media (max-width: 900px) { .player { grid-template-columns: 1fr; } }
  @media (max-width: 900px) { .player { border-right: none; border-bottom: 1px solid var(--border); } }
    @media (max-width: 900px) {
    /* stack volume and visualizer in single-column layout */
    .volume-panel { grid-column: 1 / -1; grid-row: auto; border-left: none; border-top: 1px solid var(--border); padding-top: 12px; }
    .visualizer { grid-column: 1 / -1; grid-row: auto; }
  }

  /* Now area: simple 2x2 grid */
  .now {
    display: grid;
    grid-template-columns: auto 1fr;   /* label | artist/title column */
    grid-template-rows: auto auto;     /* top row = label+artist, bottom row = track# + title */
    gap: 6px 12px;
    align-items: center;
    background: rgba(11, 18, 46, 0.84); border: 1px solid var(--border); border-radius: 14px; padding: 14px;
    box-shadow: 0 0 22px rgba(93, 251, 255, 0.08);
  }
  /* Top-left: label */
  .now-label {
    grid-column: 1 / 2;
    grid-row: 1 / 2;
    color: color-mix(in srgb, var(--muted) 40%, var(--accent) 60%);
    margin: 0;
    font-size: 16px; font-weight: 600; letter-spacing: .8px;
    align-self: center;
  }
  /* Top-right: artist fills remaining width and is right-justified */
  .now-artist {
    grid-column: 2 / 3;
    grid-row: 1 / 2;
    color: var(--muted);
    margin: 0;
    font-size: 17px; font-weight: 600;
    line-height: 1.1;
  }
  /* Bottom-left: track number */
  .now-num {
    grid-column: 1 / 2;
    grid-row: 2 / 3;
    justify-self: center;   /* center within that cell */
    min-width: var(--now-num-min, 4ch); font-variant-numeric: tabular-nums;
    color: var(--accent); letter-spacing: .6px;
    display: inline-flex; align-items: center; justify-content: center;
    padding: 8px var(--now-num-pad-x, 12px); border-radius: 999px; border: 1px solid rgba(93, 251, 255, 0.28);
    background: rgba(93, 251, 255, 0.12); font-weight: 600; line-height: 1;
  }
  /* Bottom-right: title fills remaining width and ellipses when needed */
  .now-title {
    grid-column: 2 / 3;
    grid-row: 2 / 3;
    color: var(--text);
    font-weight: 600;
  }

  .controls {
    display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
  }
  button.ctrl {
    border: 1px solid var(--border); background: rgba(12, 19, 44, 0.82); color: var(--text);
    padding: 12px 12px; border-radius: 12px; cursor: pointer; font-weight: 600;
    box-shadow: 0 0 18px rgba(93, 251, 255, 0.08); transition: border-color .2s ease, box-shadow .2s ease, transform .2s ease;
  }
  button.ctrl[aria-pressed="true"], button.ctrl.active {
    outline: 2px solid color-mix(in oklab, var(--accent) 70%, transparent); box-shadow: 0 0 24px rgba(93, 251, 255, 0.35);
  }
  button.ctrl:hover { border-color: rgba(93, 251, 255, 0.45); box-shadow: 0 0 26px rgba(93, 251, 255, 0.45); transform: translateY(-1px); }
  .seek {
    display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px; margin-top: 4px;
  }
  input[type="range"] {
    width: 100%; accent-color: var(--accent);
    background: linear-gradient(90deg, rgba(93, 251, 255, 0.45), rgba(155, 132, 255, 0.35));
    border-radius: 999px; height: 4px;
  }
  .visualizer {
    background: rgba(11, 18, 46, 0.78); border: 1px solid var(--border); border-radius: 14px; padding: 12px;
    display: grid; gap: 10px; box-shadow: 0 0 22px rgba(93, 251, 255, 0.08);
    /* span all internal player columns so it covers prev/play/next/volume area */
    grid-column: 1 / 5;
  }

  /* Volume panel when moved inside player as column 4 */
  .volume-panel {
    /* occupy the 4th internal column */
    grid-column: 4 / 5; align-self: stretch; justify-self: center;
    /* span the first 4 rows (top-controls, now, controls, seek) */
    grid-row: 1 / 5;
    /* stack label / track / percent vertically and center them */
    display: grid; grid-template-rows: auto 1fr auto; align-items: center; justify-items: center;

    padding: 12px;
    background: rgba(11, 18, 46, 0.78); border: 1px solid var(--border); border-radius: 14px;
    box-shadow: 0 0 22px rgba(93, 251, 255, 0.08);
  }
  /* volume inner container used for the label and track */
  .volume-panel .volume-label { text-align: center; }
  .volume-panel .volume-label .hint { font-size: 14px; font-weight: 600; color: var(--text); }
  .volume-panel .volume-track {
    /* let track size to its contents (the vertical input) so column remains narrow */
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    width: auto;
    box-sizing: border-box;
    overflow: visible;
    padding-top: 10px;
    padding-bottom: 10px;
  }
  .volume-vertical { display:flex; flex-direction: column; align-items:center; }
  /* vertical volume slider styling - use native vertical writing-mode for modern browsers */
  #volume.vertical {
    /* Use native vertical layout instead of rotating the control. This is supported in
       modern Chromium and produces a cleaner bounding box without overlap. */
    writing-mode: vertical-lr;
    direction: rtl;
    /* horizontal thickness and vertical length */
    width: 22px;
    height: 200px;
    display: block;
    margin: 0;
    box-sizing: border-box;
  }
  .volume-value {
    font-size: 15px; font-weight: 600; color: var(--text); margin-top: 0;
  }

   /* place the main player sections into the left 3 columns; volume-panel occupies column 4 */
  .top-controls { grid-column: 1 / 4; }
  .now { grid-column: 1 / 4; }
  .controls { grid-column: 1 / 4; }
  .seek { grid-column: 1 / 4; }
  .top-controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }

  .viz-toolbar {
    display: flex; align-items: center; justify-content: space-between; gap: 12px; font-size: 13px;
  }
  .viz-title { font-weight: 600; letter-spacing: .3px; text-transform: uppercase; color: var(--muted); }
  .viz-select {
    appearance: none; border: 1px solid var(--border); background: #101427; color: var(--text);
    padding: 6px 30px 6px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; letter-spacing: .2px;
    box-shadow: 0 0 18px rgba(93, 251, 255, 0.12); min-width: 160px;
    background-image: linear-gradient(135deg, rgba(93, 251, 255, 0.18), rgba(155, 132, 255, 0.12));
  }
  .viz-select:hover { border-color: rgba(93, 251, 255, 0.4); box-shadow: 0 0 22px rgba(93, 251, 255, 0.24); }
  .viz-select:focus {
    outline: 2px solid color-mix(in oklab, var(--accent) 65%, transparent);
    box-shadow: 0 0 22px rgba(93, 251, 255, 0.32);
  }
  .viz-select:disabled { opacity: .6; cursor: not-allowed; }
  .viz-canvas {
    width: 100%; height: 180px; border-radius: 10px; display: block;
    background: linear-gradient(180deg, rgba(4, 7, 18, 0.78), rgba(8, 14, 36, 0.82));
    box-shadow: inset 0 0 22px rgba(93, 251, 255, 0.12);
  }
  .viz-status { font-size: 12px; color: var(--muted); }
  
  .time { color: var(--muted); min-width: 108px; text-align: right; font-variant-numeric: tabular-nums; }

  .list {
    padding: 12px; overflow: auto; max-height: 610px;
    background: linear-gradient(180deg, rgba(8, 14, 36, 0.55), rgba(8, 14, 36, 0.2));
  }
  .item {
    display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 10px;
    padding: 10px 12px; border-radius: 12px; cursor: pointer; user-select: none;
    transition: background-color .18s ease, box-shadow .18s ease, transform .18s ease;
  }
  .item:hover { background: rgba(93, 251, 255, 0.08); box-shadow: 0 10px 28px rgba(2, 8, 23, 0.4); transform: translateX(2px); }
  .item.active { background: rgba(93, 251, 255, 0.16); outline: 1px solid rgba(93, 251, 255, 0.45); box-shadow: 0 0 24px rgba(93, 251, 255, 0.25); }
  .num { color: var(--muted); width: 2ch; text-align: right; text-shadow: 0 0 6px rgba(93, 251, 255, 0.35); }
  .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .dur { color: var(--muted); font-variant-numeric: tabular-nums; }
  footer {
    padding: 10px 18px 14px; display: flex; align-items: center; justify-content: space-between;
    border-top: 1px solid var(--border); color: var(--muted); font-size: 12px;
    background: linear-gradient(0deg, rgba(9, 16, 38, 0.18), transparent);
  }
  .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#0e1327; border:1px solid var(--border);
    padding: 2px 6px; border-radius: 6px; color: var(--text); box-shadow: 0 0 12px rgba(93, 251, 255, 0.12);
  }
  .hide { display: none !important; }
  .tree-root { margin-top: 4px; }
  details.tree-dir { padding-left: 0; margin: 2px 0 2px; }
  details.tree-dir > summary {
    cursor: pointer; padding: 6px 10px; border-radius: 8px;
    list-style: none; display: flex; align-items: center; gap: 8px;
    color: var(--muted); background: transparent;
  }
  details.tree-dir > summary::before {
    content: '📁'; font-size: 14px;
  }
  details.tree-dir > summary::-webkit-details-marker { display: none; }
  details.tree-dir[open] > summary { color: var(--text); background: rgba(93, 251, 255, 0.08); }
  details.tree-dir > summary:hover { background: rgba(93, 251, 255, 0.1); color: var(--text); }
  .tree-children { margin-left: 18px; border-left: 1px solid rgba(93, 251, 255, 0.2); padding-left: 10px; }
  .tree-children .item { margin: 2px 0; }
  .tree-children .num { min-width: 2.5ch; color: var(--muted); text-align: right; text-shadow: 0 0 6px rgba(93, 251, 255, 0.35); }
  .track-item { margin: 2px 0; }
  @keyframes nebulaShift {
    0% { transform: translate3d(-2%, -1%, 0) scale(1.02); }
    50% { transform: translate3d(1%, 2%, 0) scale(1.06); }
    100% { transform: translate3d(3%, -2%, 0) scale(1.03); }
  }
  @keyframes starDrift {
    0% { transform: translate3d(0, 0, 0); }
    100% { transform: translate3d(-240px, -360px, 0); }
  }
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Local MP3 Folder Player">
    <header>
      <div>
        <h1>Local MP3 Folder Player</h1>
        <div class="hint">Choose a folder to scan recursively for <strong>.mp3</strong> files (Chromium browsers).</div>
        <div class="folder-path" id="folderPath" aria-live="polite">No folder selected.</div>
      </div>
      <button class="choose" id="chooseBtn">🎵 Choose folder…</button>
    </header>

    <div class="wrap">
      <section class="player">
        <div class="top-controls" role="group" aria-label="Top controls">
          <button class="ctrl" id="shuffleBtn" aria-pressed="true" title="Toggle Shuffle (S)">🔀 Shuffle</button>
          <button class="ctrl" id="loopBtn" title="Cycle Loop (L)">🔁 Loop: All</button>
          <button class="ctrl" id="announceBtn" aria-pressed="true" title="Toggle Speech Announcements (A)">🗣 Announce On</button>
        </div>

        <div class="now" role="group" aria-labelledby="nowLabel">
          <small id="nowLabel" class="now-label">Now Playing:</small>
          <span id="nowArtist" class="now-artist">—</span>

          <span id="nowTrackNumber" class="now-num">—</span>
          <span id="nowTitle" class="now-title" aria-live="polite" aria-atomic="true">—</span>
        </div>

        <div class="controls" role="group" aria-label="Playback controls">
          <button class="ctrl" id="prevBtn" title="Previous (Cmd/Ctrl+←)">⏮ Prev</button>
          <button class="ctrl" id="playPauseBtn" title="Space">▶️ Play</button>
          <button class="ctrl" id="nextBtn" title="Next (Cmd/Ctrl+→)">⏭ Next</button>
        </div>

        <div class="seek">
          <input id="seek" type="range" min="0" max="1000" value="0" />
          <div class="time"><span id="tCur">0:00</span> / <span id="tTot">0:00</span></div>
        </div>

        <div class="volume-panel" aria-label="Volume panel">
          <div class="volume-label"><label for="volume" class="hint">Volume</label></div>
          <div class="volume-track"><input id="volume" class="vertical" type="range" min="0" max="100" value="100" title="Volume (↑/↓)" /></div>
          <div class="volume-value" id="volumeDisplay">100%</div>
        </div>

        <div class="visualizer" role="region" aria-label="Audio visualizer">
          <div class="viz-toolbar">
            <span class="viz-title" id="vizTitle">Spectrum Analyzer</span>
            <select id="vizMode" class="viz-select" aria-labelledby="vizTitle">
              <option value="bars">Neon Bars</option>
              <option value="wave">Glow Wave</option>
              <option value="radial">Pulse Halo</option>
            </select>
          </div>
          <canvas id="vizCanvas" class="viz-canvas" role="img" aria-label="Audio visualization"></canvas>
          <div class="viz-status" id="vizStatus">Select a style and start playback to visualize audio.</div>
        </div>
      </section>

      <aside class="list" id="list" aria-label="Playlist"></aside>
    </div>

    <footer>
      <div>Shortcuts: <span class="kbd">Space</span> Play/Pause · <span class="kbd">←/→</span> Seek · <span class="kbd">Cmd/Ctrl+←/→</span> Prev/Next · <span class="kbd">↑/↓</span> Volume · <span class="kbd">S</span> Shuffle · <span class="kbd">L</span> Loop · <span class="kbd">A</span> Announce</div>
      <div id="count">0 tracks</div>
    </footer>
  </div>

  <audio id="audio" class="hide" preload="metadata"></audio>

<script>
(() => {
  const chooseBtn   = document.getElementById('chooseBtn');
  const listEl      = document.getElementById('list');
  const audio       = document.getElementById('audio');
  const nowTitleEl  = document.getElementById('nowTitle');
  const nowArtistEl = document.getElementById('nowArtist');
  const nowTrackNumberEl = document.getElementById('nowTrackNumber');
  const countEl     = document.getElementById('count');

  const prevBtn     = document.getElementById('prevBtn');
  const playPauseBtn= document.getElementById('playPauseBtn');
  const nextBtn     = document.getElementById('nextBtn');
  const shuffleBtn  = document.getElementById('shuffleBtn');
  const loopBtn     = document.getElementById('loopBtn');
  const announceBtn = document.getElementById('announceBtn');

  const seek        = document.getElementById('seek');
  const tCur        = document.getElementById('tCur');
  const tTot        = document.getElementById('tTot');
  const volumeSlider= document.getElementById('volume');
  const volumeDisplay=document.getElementById('volumeDisplay');
  const folderPathEl= document.getElementById('folderPath');
  const vizModeSel  = document.getElementById('vizMode');
  const vizCanvas   = document.getElementById('vizCanvas');
  const vizStatusEl = document.getElementById('vizStatus');

  /** Persistence */
  const DB_NAME = 'lwa-player';
  const STORE_NAME = 'handles';
  const LAST_KEY = 'last-folder';
  const SHUFFLE_KEY = 'shuffle-enabled';
  const LOOP_KEY = 'loop-mode';
  const LAST_TRACK_KEY = 'last-track';
  const ANNOUNCE_KEY = 'lwa-announce-enabled';
  const VIZ_MODE_KEY = 'lwa-viz-mode';
  const VOLUME_KEY = 'lwa-volume';
  let handleDbPromise = null;
  const NAME_COLLATOR = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });

  const getHandleDb = () => {
    if (!('indexedDB' in window)) return null;
    if (!handleDbPromise) {
      handleDbPromise = new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onerror = () => reject(req.error);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
        };
        req.onsuccess = () => resolve(req.result);
      }).catch(err => {
        console.error('Failed opening handle DB', err);
        handleDbPromise = null;
        return null;
      });
    }
    return handleDbPromise;
  };

  const putStoreValue = async (key, value) => {
    const db = await getHandleDb();
    if (!db) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      tx.objectStore(STORE_NAME).put(value, key);
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });
  };

  const getStoreValue = async (key) => {
    const db = await getHandleDb();
    if (!db) return undefined;
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const req = tx.objectStore(STORE_NAME).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  };

  const saveLastHandle = async (handle) => {
    try {
      await putStoreValue(LAST_KEY, handle);
    } catch (err) {
      console.error('Failed storing folder handle', err);
    }
  };

  const loadLastHandle = async () => {
    try {
      const handle = await getStoreValue(LAST_KEY);
      return handle ?? null;
    } catch (err) {
      console.error('Failed loading folder handle', err);
      return null;
    }
  };

  const setFolderPath = (handle, { loading = false } = {}) => {
    if (!folderPathEl) return;
    if (!handle) {
      folderPathEl.textContent = 'No folder selected.';
      return;
    }
    const name = handle.name || 'Unknown folder';
    folderPathEl.textContent = loading ? `Folder: ${name} (loading...)` : `Folder: ${name}`;
  };

  /** Playlist state */
  let tracks = [];           // {name, displayName, handle, url, duration, path}
  let current = -1;
  let shuffle = true;        // toggle
  let loopMode = 'all';      // 'all' | 'one' | 'off'
  let trackRefs = new Map(); // index -> {row, durEl, ancestors}
  let rootDirName = '';
  const trackKey = (track) => [...track.path, track.name].join('/');
  const speech = createSpeechSynth();
  let announceEnabled = speech.supported;
  let pendingAnnouncement = null;
  let lastAnnouncedSummary = null;
  let lastAnnouncedTrackKey = null;
  let lastAnnouncedArtist = null;
  let lastAnnouncedTitle = null;
  let announceTimer = null;

  /** Media Session API support */
  const mediaSessionSupported = 'mediaSession' in navigator;

  const applyNowTrackMetrics = () => {
    if (!nowTrackNumberEl) return;
    if (!tracks.length) {
      nowTrackNumberEl.style.removeProperty('--now-num-min');
      nowTrackNumberEl.style.removeProperty('--now-num-pad-x');
      return;
    }
    const digits = Math.max(1, String(tracks.length).length);
    const minCh = Math.max(4, digits + 1);
    nowTrackNumberEl.style.setProperty('--now-num-min', `${minCh}ch`);
    const padX = Math.min(26, 16 + Math.max(0, digits - 2) * 5);
    nowTrackNumberEl.style.setProperty('--now-num-pad-x', `${padX}px`);
  };

  applyNowTrackMetrics();

  /** Update Media Session metadata */
  const updateMediaSessionMetadata = (track) => {
    if (!mediaSessionSupported || !track) return;
    try {
      const details = buildAnnouncementDetails(track);
      const title = details.title || track.displayName || 'Unknown Track';
      const artist = details.artist || 'Unknown Artist';
      navigator.mediaSession.metadata = new MediaMetadata({
        title,
        artist,
        album: rootDirName || 'Local Collection',
      });
    } catch (err) {
      console.warn('Failed updating Media Session metadata', err);
    }
  };

  /** Set up Media Session action handlers */
  const setupMediaSessionHandlers = () => {
    if (!mediaSessionSupported) {
      console.info('Media Session API not supported in this browser');
      return;
    }
    try {
      navigator.mediaSession.setActionHandler('play', async () => {
        if (tracks.length && audio.paused) {
          try {
            await audio.play();
            playPauseBtn.textContent = '⏸ Pause';
          } catch (e) {
            console.error('Failed to play via Media Session', e);
          }
        }
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        if (!audio.paused) {
          audio.pause();
          playPauseBtn.textContent = '▶️ Play';
        }
      });
      navigator.mediaSession.setActionHandler('previoustrack', () => {
        if (tracks.length) playIndex(prevIndex(), { autoplay: true, skipReason: 'manual' });
      });
      navigator.mediaSession.setActionHandler('nexttrack', () => {
        if (tracks.length) playIndex(nextIndex(), { autoplay: true, skipReason: 'manual' });
      });
      navigator.mediaSession.setActionHandler('seekbackward', (details) => {
        if (!isFinite(audio.duration) || audio.duration <= 0) return;
        const skipTime = details.seekOffset || 10;
        audio.currentTime = Math.max(audio.currentTime - skipTime, 0);
      });
      navigator.mediaSession.setActionHandler('seekforward', (details) => {
        if (!isFinite(audio.duration) || audio.duration <= 0) return;
        const skipTime = details.seekOffset || 10;
        audio.currentTime = Math.min(audio.currentTime + skipTime, audio.duration);
      });
      navigator.mediaSession.setActionHandler('seekto', (details) => {
        if (!isFinite(audio.duration) || audio.duration <= 0) return;
        if (typeof details.seekTime !== 'number' || details.seekTime < 0) return;
        const targetTime = Math.min(details.seekTime, audio.duration);
        if (details.fastSeek && 'fastSeek' in audio) {
          audio.fastSeek(targetTime);
        } else {
          audio.currentTime = targetTime;
        }
      });
    } catch (err) {
      console.warn('Failed setting up Media Session handlers', err);
    }
  };

  /** Update Media Session playback state */
  const updateMediaSessionPlaybackState = (state) => {
    if (!mediaSessionSupported) return;
    try {
      navigator.mediaSession.playbackState = state;
    } catch (err) {
      console.warn('Failed updating Media Session playback state', err);
    }
  };

  /** Update Media Session position state */
  const updateMediaSessionPositionState = () => {
    if (!mediaSessionSupported) return;
    if (!isFinite(audio.duration) || audio.duration <= 0) return;
    try {
      navigator.mediaSession.setPositionState({
        duration: audio.duration,
        playbackRate: audio.playbackRate,
        position: audio.currentTime,
      });
    } catch (err) {
      console.warn('Failed updating Media Session position state', err);
    }
  };

  // Initialize Media Session handlers
  setupMediaSessionHandlers();

  // Debounce delay for speech announcements.
  // 250ms prevents announcement spam during rapid track skipping,
  // and provides time for the audio to stabilize before speaking.
  const ANNOUNCE_DEBOUNCE_MS = 250;

  /** Visualizer */
  const AudioContextCtor = window.AudioContext || window.webkitAudioContext || null;
  const VIZ_FFT_SIZE = 2048;
  const VIZ_BAR_COUNT = 64;
  const VIZ_LABELS = {
    bars: 'Neon Bars',
    wave: 'Glow Wave',
    radial: 'Pulse Halo',
  };
  const DEFAULT_VIZ_MODE = 'bars';
  let vizMode = DEFAULT_VIZ_MODE;
  let vizAudioCtx = null;
  let vizAnalyser = null;
  let vizSourceNode = null;
  let vizFreqData = null;
  let vizTimeData = null;
  let vizFrame = null;
  const vizCtx = vizCanvas ? vizCanvas.getContext('2d') : null;

  const updateVizStatus = (state = 'idle') => {
    if (!vizStatusEl) return;
    if (!AudioContextCtor || !vizCanvas || !vizCtx) {
      vizStatusEl.textContent = 'Visualizer not supported in this browser.';
      return;
    }
    const label = VIZ_LABELS[vizMode] || VIZ_LABELS[DEFAULT_VIZ_MODE];
    if (state === 'playing') {
      vizStatusEl.textContent = `${label} visualization running.`;
    } else if (state === 'paused') {
      vizStatusEl.textContent = `${label} visualization paused.`;
    } else {
      vizStatusEl.textContent = `Style: ${label}. Start playback to visualize audio.`;
    }
  };

  const readVizModePreference = () => {
    try {
      const stored = localStorage.getItem(VIZ_MODE_KEY);
      if (stored && VIZ_LABELS[stored]) return stored;
    } catch (err) {
      console.warn('Unable to read visualizer preference', err);
    }
    return DEFAULT_VIZ_MODE;
  };

  const persistVizModePreference = (value) => {
    try {
      localStorage.setItem(VIZ_MODE_KEY, value);
    } catch (err) {
      console.warn('Unable to store visualizer preference', err);
    }
  };

  const setVizMode = (value, { persist = false } = {}) => {
    const next = VIZ_LABELS[value] ? value : DEFAULT_VIZ_MODE;
    vizMode = next;
    if (vizModeSel && vizModeSel.value !== next) {
      vizModeSel.value = next;
    }
    if (persist) persistVizModePreference(next);
    updateVizStatus(audio && !audio.paused && !audio.ended ? 'playing' : 'idle');
  };

  const syncCanvasDimensions = () => {
    if (!vizCanvas || !vizCtx) return { width: 0, height: 0 };
    const rect = vizCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const width = Math.max(1, Math.floor(rect.width * dpr));
    const height = Math.max(1, Math.floor(rect.height * dpr));
    if (vizCanvas.width !== width || vizCanvas.height !== height) {
      vizCanvas.width = width;
      vizCanvas.height = height;
      vizCtx.setTransform(1, 0, 0, 1, 0, 0);
      vizCtx.scale(dpr, dpr);
    }
    return { width: rect.width, height: rect.height };
  };

  const ensureVisualizerNodes = () => {
    if (!AudioContextCtor || !vizCanvas || !vizCtx) return false;
    if (!vizAudioCtx) {
      try {
        vizAudioCtx = new AudioContextCtor();
      } catch (err) {
        console.error('Unable to create AudioContext', err);
        return false;
      }
    }
    if (!vizAnalyser) {
      vizAnalyser = vizAudioCtx.createAnalyser();
      vizAnalyser.fftSize = VIZ_FFT_SIZE;
      vizAnalyser.smoothingTimeConstant = 0.82;
      vizAnalyser.minDecibels = -90;
      vizAnalyser.maxDecibels = -10;
    }
    if (!vizSourceNode) {
      vizSourceNode = vizAudioCtx.createMediaElementSource(audio);
      vizSourceNode.connect(vizAnalyser);
      vizAnalyser.connect(vizAudioCtx.destination);
    }
    if (vizAudioCtx.state === 'suspended') {
      vizAudioCtx.resume().catch(err => {
        console.warn('Unable to resume AudioContext', err);
      });
    }
    if (!vizFreqData || vizFreqData.length !== vizAnalyser.frequencyBinCount) {
      vizFreqData = new Uint8Array(vizAnalyser.frequencyBinCount);
    }
    if (!vizTimeData || vizTimeData.length !== vizAnalyser.fftSize) {
      vizTimeData = new Uint8Array(vizAnalyser.fftSize);
    }
    return true;
  };

  const drawBars = (width, height) => {
    if (!vizAnalyser) return;
    vizAnalyser.getByteFrequencyData(vizFreqData);
    vizCtx.fillStyle = 'rgba(4, 7, 18, 0.78)';
    vizCtx.fillRect(0, 0, width, height);
    const barCount = VIZ_BAR_COUNT;
    const step = Math.max(1, Math.floor(vizFreqData.length / barCount));
    const barWidth = width / barCount;
    for (let i = 0; i < barCount; i++) {
      const magnitude = vizFreqData[i * step] / 255;
      const eased = Math.pow(magnitude, 1.6);
      const barHeight = Math.max(4, eased * height);
      const x = i * barWidth;
      const gradient = vizCtx.createLinearGradient(x, height - barHeight, x, height);
      gradient.addColorStop(0, 'rgba(149, 132, 255, 0.92)');
      gradient.addColorStop(1, 'rgba(93, 251, 255, 0.92)');
      vizCtx.fillStyle = gradient;
      vizCtx.fillRect(x + 1, height - barHeight, Math.max(1.5, barWidth - 2), barHeight);
    }
  };

  const drawWave = (width, height) => {
    if (!vizAnalyser) return;
    vizAnalyser.getByteTimeDomainData(vizTimeData);
    vizCtx.fillStyle = 'rgba(4, 7, 18, 0.78)';
    vizCtx.fillRect(0, 0, width, height);
    const gradient = vizCtx.createLinearGradient(0, 0, width, 0);
    gradient.addColorStop(0, 'rgba(93, 251, 255, 0.85)');
    gradient.addColorStop(1, 'rgba(155, 132, 255, 0.85)');
    vizCtx.lineWidth = 2;
    vizCtx.strokeStyle = gradient;
    vizCtx.shadowColor = 'rgba(93, 251, 255, 0.35)';
    vizCtx.shadowBlur = 12;
    vizCtx.beginPath();
    const slice = width / vizTimeData.length;
    for (let i = 0; i < vizTimeData.length; i++) {
      const value = (vizTimeData[i] - 128) / 128;
      const y = height / 2 + value * (height / 2 - 6);
      const x = i * slice;
      if (i === 0) vizCtx.moveTo(x, y);
      else vizCtx.lineTo(x, y);
    }
    vizCtx.stroke();
    vizCtx.shadowBlur = 0;
    vizCtx.beginPath();
    vizCtx.fillStyle = 'rgba(93, 251, 255, 0.08)';
    vizCtx.fillRect(0, height / 2, width, 1);
  };

  const drawRadial = (width, height) => {
    if (!vizAnalyser) return;
    const RADIAL_POINT_COUNT = 90;
    vizAnalyser.getByteFrequencyData(vizFreqData);
    vizCtx.fillStyle = 'rgba(4, 7, 18, 0.78)';
    vizCtx.fillRect(0, 0, width, height);
    const centerX = width / 2;
    const centerY = height / 2;
    const baseRadius = Math.min(width, height) * 0.22;
    const maxRadius = Math.min(width, height) * 0.48;
    const count = RADIAL_POINT_COUNT;
    const step = Math.max(1, Math.floor(vizFreqData.length / count));
    vizCtx.save();
    vizCtx.translate(centerX, centerY);
    vizCtx.lineWidth = 2;
    for (let i = 0; i < count; i++) {
      const value = vizFreqData[i * step] / 255;
      const magnitude = baseRadius + (maxRadius - baseRadius) * Math.pow(value, 1.45);
      const angle = (i / count) * Math.PI * 2;
      const x = Math.cos(angle) * magnitude;
      const y = Math.sin(angle) * magnitude;
      vizCtx.beginPath();
      vizCtx.strokeStyle = `rgba(93, 251, 255, ${0.12 + value * 0.75})`;
      vizCtx.moveTo(Math.cos(angle) * baseRadius, Math.sin(angle) * baseRadius);
      vizCtx.lineTo(x, y);
      vizCtx.stroke();
    }
    const pulse = vizCtx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, baseRadius);
    pulse.addColorStop(0, 'rgba(93, 251, 255, 0.28)');
    pulse.addColorStop(1, 'rgba(149, 132, 255, 0.05)');
    vizCtx.beginPath();
    vizCtx.fillStyle = pulse;
    vizCtx.arc(0, 0, baseRadius, 0, Math.PI * 2);
    vizCtx.fill();
    vizCtx.restore();
  };

  const VIZ_DRAWERS = {
    bars: drawBars,
    wave: drawWave,
    radial: drawRadial,
  };

  const renderVisualizer = () => {
    if (!vizCtx || !vizAnalyser) return;
    const { width, height } = syncCanvasDimensions();
    if (!width || !height) {
      vizFrame = requestAnimationFrame(renderVisualizer);
      return;
    }
    const draw = VIZ_DRAWERS[vizMode] || VIZ_DRAWERS[DEFAULT_VIZ_MODE];
    draw(width, height);
    vizFrame = requestAnimationFrame(renderVisualizer);
  };

  const startVisualizer = () => {
    if (!ensureVisualizerNodes()) return;
    if (!vizFrame) {
      vizFrame = requestAnimationFrame(renderVisualizer);
    }
    updateVizStatus('playing');
  };

  const stopVisualizer = ({ clear = false, state = 'paused' } = {}) => {
    if (vizFrame) {
      cancelAnimationFrame(vizFrame);
      vizFrame = null;
    }
    if (clear && vizCtx) {
      const { width, height } = syncCanvasDimensions();
      if (width && height) {
        vizCtx.clearRect(0, 0, width, height);
      }
    }
    updateVizStatus(state);
  };

  if (vizModeSel) {
    setVizMode(readVizModePreference());
    vizModeSel.addEventListener('change', () => setVizMode(vizModeSel.value, { persist: true }));
    if (!AudioContextCtor || !vizCanvas || !vizCtx) {
      vizModeSel.disabled = true;
      vizModeSel.title = 'Audio visualizer is not available in this browser.';
    }
  } else {
    setVizMode(readVizModePreference());
  }

  updateVizStatus();

  /** Utilities */
  const fmtTime = s => {
    if (!isFinite(s) || s < 0) s = 0;
    const m = Math.floor(s / 60), ss = Math.floor(s % 60);
    return `${m}:${ss.toString().padStart(2,'0')}`;
  };
  const fmtTrackNumber = (idx) => {
    if (!tracks.length || idx < 0 || idx >= tracks.length) return '—';
    const digits = Math.max(1, String(tracks.length).length);
    return `#${String(idx + 1).padStart(digits, '0')}`;
  };
  const normalizeSpaces = (value) => {
    if (!value) return '';
    return value.replace(/\s+/g, ' ').trim();
  };
  const stripTrailingTags = (value) => value.replace(/\s*[\[\(][^)\]]*[\)\]]\s*$/g, '').trim();
  const resolveFolderKey = (track) => normalizeSpaces(track.path[0] || rootDirName || '').toLowerCase();

  const ANNOUNCE_RULES = [
    {
      matches: (track) => resolveFolderKey(track) === 'utho riley',
      format: (name) => {
        const base = stripTrailingTags(name).split(' - ')[0] || name;
        const title = normalizeSpaces(base.replace(/｜.*$/u, ''));
        return { title, artist: 'Utho Riley' };
      },
    },
    {
      matches: (track) => resolveFolderKey(track) === 'white bat audio',
      format: (name) => {
        let working = stripTrailingTags(name);
        const parts = working.split(' - ');
        let title = parts[1] ? parts[1] : working;
        title = title.replace(/\s*(⧸⧸|\/\/).*$/u, '');
        return { title: normalizeSpaces(title), artist: 'White Bat Audio' };
      },
    },
  ];

  const buildAnnouncementDetails = (track) => {
    const fallbackArtistRaw = (track.path[0] || rootDirName || '').replace(/[_]+/g, ' ');
    const fallbackArtist = normalizeSpaces(fallbackArtistRaw) || 'Unknown artist';
    const baseName = normalizeSpaces(track.displayName.replace(/[_]+/g, ' '));
    const sanitized = stripTrailingTags(baseName);

    const rule = ANNOUNCE_RULES.find(rule => rule.matches(track));
    if (rule) {
      const result = rule.format(sanitized) || {};
      const titleRaw = result.title || sanitized;
      const artistRaw = result.artist || fallbackArtist;
      const title = normalizeSpaces(titleRaw) || 'Unknown track';
      const artist = normalizeSpaces(artistRaw);
      const summary = artist ? `${title}, by ${artist}` : title;
      return { title, artist, summary };
    }

    const fallbackName = sanitized.replace(/\s*(⧸⧸|\/\/|｜).*$/u, '').trim() || sanitized;
    const normalized = fallbackName.replace(/[–—]/g, '-');
    const parts = normalized.split(' - ');
    let title = parts.length >= 2 ? normalizeSpaces(parts.slice(1).join(' - ')) : fallbackName;
    if (!title) title = fallbackName;
    let artist = parts.length >= 2 ? normalizeSpaces(parts[0].replace(/^\d+[\s.\-]*/, '')) : fallbackArtist;
    if (!artist) artist = fallbackArtist;
    title = normalizeSpaces(title) || 'Unknown track';
    artist = normalizeSpaces(artist);
    const summary = artist ? `${title}, by ${artist}` : title;
    return { title, artist, summary };
  };

  const recordPendingAnnouncement = (track, { skipReason = 'auto' } = {}) => {
    if (!track) {
      pendingAnnouncement = null;
      return null;
    }
    const details = buildAnnouncementDetails(track);
    const { title = '', artist = '', summary = '' } = details || {};
    pendingAnnouncement = {
      key: trackKey(track),
      title,
      artist,
      summary,
      skipReason,
    };
    return details;
  };

  const maybeAnnounceCurrentTrack = () => {
    if (!pendingAnnouncement) return;
    const { key, summary, artist, title, skipReason } = pendingAnnouncement;
    pendingAnnouncement = null;
    if (!summary) return;

    // Announcements are disabled by the user.
    if (!announceEnabled) return;
    // Speech synthesis is not available in this browser.
    if (!speech.supported) return;
    // Avoid repeating the same announcement if the track restarts.
    if (key === lastAnnouncedTrackKey) return;

    let message = '';
    if (lastAnnouncedSummary && lastAnnouncedSummary !== summary) {
      let previousDescription = lastAnnouncedSummary;
      if (lastAnnouncedTitle) {
        const includePrevArtist = Boolean(lastAnnouncedArtist) &&
          (!artist || NAME_COLLATOR.compare(lastAnnouncedArtist, artist) !== 0);
        previousDescription = includePrevArtist
          ? `${lastAnnouncedTitle}, by ${lastAnnouncedArtist}`
          : lastAnnouncedTitle;
      }
      if (previousDescription) {
        // Use "Skipped" for manual transitions, "That was" for automatic
        const transitionVerb = skipReason === 'manual' ? 'Skipped' : 'That was';
        message = `${transitionVerb} ${previousDescription}. `;
      }
    }
    let sameArtist = false;
    if (artist && lastAnnouncedArtist) {
      sameArtist = (NAME_COLLATOR.compare(artist, lastAnnouncedArtist) === 0);
    }
    const shouldIncludeArtist = Boolean(artist) && !sameArtist;
    const nowDescription = shouldIncludeArtist ? summary : (title || summary);
    message += `Now playing, ${nowDescription}`;
    if (announceTimer) {
      clearTimeout(announceTimer);
      announceTimer = null;
    }
    const dispatchAnnouncement = () => {
      speech.speak(message, { interrupt: true });
      lastAnnouncedSummary = summary;
      lastAnnouncedTrackKey = key;
      lastAnnouncedArtist = artist ?? null;
      lastAnnouncedTitle = title ?? null;
      announceTimer = null;
    };
    if (ANNOUNCE_DEBOUNCE_MS > 0) {
      announceTimer = setTimeout(dispatchAnnouncement, ANNOUNCE_DEBOUNCE_MS);
    } else {
      dispatchAnnouncement();
    }
  };

  const readAnnouncePreference = () => {
    try {
      const stored = localStorage.getItem(ANNOUNCE_KEY);
      if (stored === null) return true;
      return stored === '1';
    } catch (err) {
      console.warn('Unable to read announce preference', err);
      return true;
    }
  };

  const setAnnounceEnabled = (value, { persist = true } = {}) => {
    const effective = Boolean(value && speech.supported);
    announceEnabled = effective;
    if (announceBtn) {
      announceBtn.setAttribute('aria-pressed', String(effective));
      announceBtn.classList.toggle('active', effective);
      announceBtn.textContent = effective ? '🗣 Announce On' : '🤫 Announce Off';
    }
    if (persist && speech.supported) {
      try { localStorage.setItem(ANNOUNCE_KEY, effective ? '1' : '0'); }
      catch (err) { console.warn('Unable to store announce preference', err); }
    }
    if (!effective) {
      speech.cancel();
      if (announceTimer) {
        clearTimeout(announceTimer);
        announceTimer = null;
      }
    } else if (audio && !audio.paused && current >= 0 && tracks[current]) {
      // Allow a fresh announcement when the toggle is re-enabled mid-track.
      lastAnnouncedTrackKey = null;
      lastAnnouncedArtist = null;
      lastAnnouncedTitle = null;
      recordPendingAnnouncement(tracks[current]);
      maybeAnnounceCurrentTrack();
    }
  };

  function createSpeechSynth() {
    const synth = window.speechSynthesis;
    if (!(synth && 'SpeechSynthesisUtterance' in window)) {
      console.warn('Speech synthesis not supported in this browser');
      return {
        supported: false,
        speak: () => {},
        cancel: () => {},
      };
    }

    // Prefer Daniel for consistent pacing; fall back to any English voice, then any remaining option.
    // Daniel is preferred because it offers clear articulation, a neutral British accent, and steady pacing, making it highly intelligible and suitable for track announcements.
    const PREFERRED_VOICE_NAMES = [
      'Daniel (English (United Kingdom))',
      'Daniel (English (United States))',
      'Daniel',
    ];
    let voice = null;
    let queued = null;
    let awaitingVoices = false;

    function pickVoice() {
      const voices = synth.getVoices();
      if (!voices.length) return null;
      let best = null;
      let bestScore = -1;
      for (const v of voices) {
        let score = 0;
        if (PREFERRED_VOICE_NAMES.includes(v.name)) score = 3;
        else if (v.lang && v.lang.toLowerCase().startsWith('en') && v.localService) score = 2;
        else if (v.lang && v.lang.toLowerCase().startsWith('en')) score = 1;
        if (score > bestScore) {
          best = v;
          bestScore = score;
          if (score === 3) break;
        }
      }
      voice = best || voices[0];
      return voice;
    }

    function handleVoicesChanged() {
      if (voice) return;
      if (!pickVoice()) return;
      synth.removeEventListener('voiceschanged', handleVoicesChanged);
      awaitingVoices = false;
      if (queued) {
        const { text, opts } = queued;
        queued = null;
        speak(text, opts);
      }
    }

    function ensureVoice() {
      if (voice) return true;
      if (pickVoice()) return true;
      if (!awaitingVoices) {
        awaitingVoices = true;
        synth.addEventListener('voiceschanged', handleVoicesChanged);
      }
      return false;
    }

    function speak(text, opts = {}) {
      if (!text) return;
      if (!ensureVoice()) {
        queued = { text, opts };
        return;
      }
      const shouldInterrupt = opts.interrupt ?? true;
      if (shouldInterrupt) synth.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      if (voice) {
        utter.voice = voice;
        utter.lang = voice.lang;
      }
      utter.volume = opts.volume ?? 1;
      utter.rate = opts.rate ?? 1;
      utter.pitch = opts.pitch ?? 1;
      synth.speak(utter);
    }

    function cancel() {
      synth.cancel();
      queued = null;
    }

    return { supported: true, speak, cancel };
  }

  const revokeAll = () => {
    tracks.forEach(t => { if (t.url) URL.revokeObjectURL(t.url); });
  };

  async function* walk(dir, path = []) {
    for await (const [name, handle] of dir.entries()) {
      if (handle.kind === 'file') {
        if (name.toLowerCase().endsWith('.mp3')) {
          yield { name, handle, path };
        }
      } else if (handle.kind === 'directory') {
        if (!name.startsWith('.')) {
          yield* walk(handle, [...path, name]);
        }
      }
    }
  }

  async function scanFolder(dirHandle) {
    setFolderPath(dirHandle, { loading: true });
    rootDirName = dirHandle?.name || 'Selected Folder';
    tracks = [];
    current = -1;
    pendingAnnouncement = null;
    lastAnnouncedSummary = null;
    lastAnnouncedTrackKey = null;
    lastAnnouncedArtist = null;
    lastAnnouncedTitle = null;
    stopVisualizer({ clear: true, state: 'idle' });
    if (announceTimer) {
      clearTimeout(announceTimer);
      announceTimer = null;
    }
    revokeAll();
    listEl.innerHTML = '';
    if (nowTitleEl) nowTitleEl.textContent = '—';
    if (nowArtistEl) nowArtistEl.textContent = '—';
    if (nowTrackNumberEl) nowTrackNumberEl.textContent = '—';
    applyNowTrackMetrics();
    countEl.textContent = 'Scanning…';

    try {
      for await (const entry of walk(dirHandle)) {
        const { handle: fh, path } = entry;
        const file = await fh.getFile();
        const url = URL.createObjectURL(file);
        tracks.push({
          name: file.name,
          displayName: file.name.replace(/\.mp3$/i, ''),
          handle: fh,
          url,
          duration: NaN,
          path: [...path],
        });
      }
    } catch (err) {
      console.error('Failed scanning folder', err);
      tracks = [];
      applyNowTrackMetrics();
    }

    tracks.sort((a, b) => NAME_COLLATOR.compare(trackKey(a), trackKey(b)));
    applyNowTrackMetrics();

    renderList();
    countEl.textContent = `${tracks.length} track${tracks.length===1?'':'s'}`;
    if (tracks.length) {
      let targetIdx = 0;
      try {
        const storedKey = await getStoreValue(LAST_TRACK_KEY);
        if (typeof storedKey === 'string') {
          const found = tracks.findIndex(t => trackKey(t) === storedKey);
          if (found >= 0) {
            targetIdx = found;
          } else if (shuffle && tracks.length > 1) {
            targetIdx = Math.floor(Math.random() * tracks.length);
            console.info('Last known track missing; selecting a random track because shuffle is on.');
          } else {
            console.info('Last known track not found; defaulting to first track.');
          }
        }
      } catch (err) {
        console.error('Failed loading last track', err);
      }
      playIndex(targetIdx, {autoplay:false});
    }
    setFolderPath(dirHandle);
  }

  if (announceBtn) {
    if (speech.supported) {
      const initial = readAnnouncePreference();
      setAnnounceEnabled(initial, { persist: false });
      announceBtn.addEventListener('click', () => setAnnounceEnabled(!announceEnabled));
    } else {
      announceBtn.textContent = '🚫 Announce Unavailable';
      announceBtn.disabled = true;
      announceBtn.title = 'Speech synthesis not supported in this browser.';
      announceBtn.setAttribute('aria-disabled', 'true');
      announceBtn.setAttribute('aria-pressed', 'false');
      announceBtn.classList.remove('active');
    }
  }

  function renderList() {
    trackRefs = new Map();
    listEl.innerHTML = '';
    if (!tracks.length) {
      highlightActive();
      return;
    }

    const tree = buildTrackTree();
    const wrapper = document.createElement('div');
    wrapper.className = 'tree-root';

    const topDirs = Array.from(tree.dirs.values()).sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    topDirs.forEach(dir => wrapper.appendChild(renderDirNode(dir, 0, [])));

    const rootFiles = tree.files.slice().sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    rootFiles.forEach(file => wrapper.appendChild(renderTrackLeaf(file.index, [])));

    listEl.appendChild(wrapper);
    highlightActive();
  }

  function buildTrackTree() {
    const root = { name: rootDirName, dirs: new Map(), files: [] };
    tracks.forEach((track, index) => {
      let node = root;
      track.path.forEach(segment => {
        if (!node.dirs.has(segment)) {
          node.dirs.set(segment, { name: segment, dirs: new Map(), files: [] });
        }
        node = node.dirs.get(segment);
      });
      node.files.push({ name: track.name, index });
    });
    return root;
  }

  function renderDirNode(node, depth, ancestors) {
    const details = document.createElement('details');
    details.className = 'tree-dir';
    if (depth < 1) details.open = true;

    const summary = document.createElement('summary');
    summary.textContent = node.name;
    details.appendChild(summary);

    const children = document.createElement('div');
    children.className = 'tree-children';
    const nextAncestors = ancestors.concat(details);

    const subDirs = Array.from(node.dirs.values()).sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    subDirs.forEach(child => children.appendChild(renderDirNode(child, depth + 1, nextAncestors)));

    const files = node.files.slice().sort((a, b) => NAME_COLLATOR.compare(a.name, b.name));
    files.forEach(file => children.appendChild(renderTrackLeaf(file.index, nextAncestors)));

    if (children.children.length) details.appendChild(children);
    return details;
  }

  function renderTrackLeaf(index, ancestors) {
    const track = tracks[index];
    const row = document.createElement('div');
    row.className = 'item track-item';
    row.dataset.index = index;
    row.role = 'button';
    row.tabIndex = 0;
    const relative = track.path.length ? `${track.path.join('/')}/${track.name}` : track.name;
    row.title = relative;

    const icon = document.createElement('div');
    icon.className = 'num';
    icon.textContent = index + 1;

    const nameEl = document.createElement('div');
    nameEl.className = 'name';
    nameEl.textContent = track.displayName;

    const durEl = document.createElement('div');
    durEl.className = 'dur';
    durEl.textContent = isFinite(track.duration) ? fmtTime(track.duration) : '';

    row.append(icon, nameEl, durEl);
    row.addEventListener('click', () => playIndex(index, {autoplay:true, skipReason:'manual'}));
    row.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        playIndex(index, {autoplay:true, skipReason:'manual'});
      }
    });

    trackRefs.set(index, { row, durEl, ancestors });
    if (!isFinite(track.duration)) {
      primeDuration(index, durEl);
    }

    return row;
  }

  function primeDuration(index, durEl) {
    const track = tracks[index];
    const tmp = new Audio();
    tmp.preload = 'metadata';
    tmp.src = track.url;
    const clearTmp = () => {
      tmp.src = '';
      try { tmp.load(); } catch (_) {}
    };
    tmp.addEventListener('loadedmetadata', () => {
      track.duration = tmp.duration;
      if (durEl.isConnected) {
        durEl.textContent = isFinite(track.duration) ? fmtTime(track.duration) : '';
      }
      clearTmp();
    }, {once:true});
    tmp.addEventListener('error', clearTmp, {once:true});
  }

  function highlightActive() {
    trackRefs.forEach(ref => ref.row.classList.remove('active'));
    if (current < 0) return;
    const ref = trackRefs.get(current);
    if (!ref) return;
    ref.row.classList.add('active');
    ref.ancestors.forEach(det => {
      if (det && !det.open) det.open = true;
    });
    if (ref.row.isConnected) {
      ref.row.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }

  function applyShuffleState() {
    shuffleBtn.setAttribute('aria-pressed', String(shuffle));
    shuffleBtn.classList.toggle('active', shuffle);
  }

  function setLoopLabel() {
    const labels = { all: '🔁 Loop: All', one: '🔂 Loop: One', off: '⏹ Loop: Off' };
    loopBtn.textContent = labels[loopMode];
    audio.loop = (loopMode === 'one');
  }

  const VOLUME_STEP = 5;  // 5% volume change per arrow key press
  const SEEK_STEP = 5;     // 5 seconds seek forward/backward per arrow key press

  function setVolume(value, { persist = true } = {}) {
    const clampedValue = Math.max(0, Math.min(100, Math.round(value)));
    audio.volume = clampedValue / 100;
    if (volumeSlider) volumeSlider.value = String(clampedValue);
    if (volumeDisplay) volumeDisplay.textContent = `${clampedValue}%`;
    
    if (persist) {
      putStoreValue(VOLUME_KEY, clampedValue).catch(err => {
        console.error('Failed storing volume preference', err);
      });
    }
  }

  function adjustVolume(delta) {
    const currentVolume = Math.round(audio.volume * 100);
    setVolume(currentVolume + delta);
  }

  function seekBy(seconds) {
    if (!isFinite(audio.duration) || audio.duration <= 0) return;
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
  }

  async function playIndex(idx, {autoplay=true, skipReason='auto'} = {}) {
    if (!tracks.length) return;
    if (idx < 0) idx = 0;
    if (idx >= tracks.length) idx = tracks.length - 1;
    current = idx;

    const tr = tracks[current];
    const details = recordPendingAnnouncement(tr, { skipReason });
    audio.src = tr.url;
    if (nowTitleEl) nowTitleEl.textContent = tr.displayName;
    if (nowArtistEl) nowArtistEl.textContent = (details && details.artist) ? details.artist : '—';
    if (nowTrackNumberEl) nowTrackNumberEl.textContent = fmtTrackNumber(current);
    highlightActive();
    updateMediaSessionMetadata(tr);
    putStoreValue(LAST_TRACK_KEY, trackKey(tr)).catch(err => {
      console.error('Failed storing last track', err);
    });

    // Reset UI time
    seek.value = 0;
    tCur.textContent = '0:00';
    tTot.textContent = isFinite(tr.duration) ? fmtTime(tr.duration) : '0:00';

    if (autoplay) {
      try { await audio.play(); playPauseBtn.textContent = '⏸ Pause'; }
      catch(e){ /* ignore autoplay block */ }
    } else {
      playPauseBtn.textContent = '▶️ Play';
    }
  }

  function nextIndex() {
    if (!tracks.length) return current;
    if (shuffle && tracks.length > 1) {
      // random but avoid immediate repeat
      let idx;
      do { idx = Math.floor(Math.random() * tracks.length); } while (idx === current);
      return idx;
    }
    // linear advance, wrap if loop all, else clamp at end (handled in ended)
    let idx = current + 1;
    if (idx >= tracks.length) idx = 0;
    return idx;
  }

  function prevIndex() {
    if (!tracks.length) return current;
    if (shuffle && tracks.length > 1) {
      let idx;
      do { idx = Math.floor(Math.random() * tracks.length); } while (idx === current);
      return idx;
    }
    let idx = current - 1;
    if (idx < 0) idx = tracks.length - 1;
    return idx;
  }

  const loadPreferences = async () => {
    try {
      const storedShuffle = await getStoreValue(SHUFFLE_KEY);
      if (typeof storedShuffle === 'boolean') shuffle = storedShuffle;
    } catch (err) {
      console.error('Failed loading shuffle preference', err);
    }
    applyShuffleState();

    try {
      const storedLoop = await getStoreValue(LOOP_KEY);
      if (storedLoop === 'all' || storedLoop === 'one' || storedLoop === 'off') {
        loopMode = storedLoop;
      }
    } catch (err) {
      console.error('Failed loading loop preference', err);
    }
    setLoopLabel();

    try {
      const storedVolume = await getStoreValue(VOLUME_KEY);
      if (typeof storedVolume === 'number' && storedVolume >= 0 && storedVolume <= 100) {
        setVolume(storedVolume, { persist: false });
      } else {
        setVolume(100, { persist: false });
      }
    } catch (err) {
      console.error('Failed loading volume preference', err);
      setVolume(100, { persist: false });
    }
  };

  /** Event wiring */
  applyShuffleState();
  setLoopLabel();
  loadPreferences();

  chooseBtn.addEventListener('click', async () => {
    if (!('showDirectoryPicker' in window)) {
      alert('Your browser does not support picking folders. Use a Chromium-based browser like Chrome or Edge.');
      return;
    }
    try {
      const dir = await window.showDirectoryPicker({ id: 'mp3-player-root' });
      const perm = await dir.requestPermission({ mode: 'read' });
      if (perm === 'granted') {
        await scanFolder(dir);
        await saveLastHandle(dir);
      } else { alert('Read permission was not granted.'); }
    } catch (e) {
      if (e?.name !== 'AbortError') console.error(e);
    }
  });

  playPauseBtn.addEventListener('click', async () => {
    if (!tracks.length) return;
    if (audio.paused) {
      try { await audio.play(); playPauseBtn.textContent = '⏸ Pause'; } catch(e){}
    } else {
      audio.pause(); playPauseBtn.textContent = '▶️ Play';
    }
  });

  nextBtn.addEventListener('click', () => playIndex(nextIndex(), {autoplay:true, skipReason:'manual'}));
  prevBtn.addEventListener('click', () => playIndex(prevIndex(), {autoplay:true, skipReason:'manual'}));

  shuffleBtn.addEventListener('click', () => {
    shuffle = !shuffle;
    applyShuffleState();
    putStoreValue(SHUFFLE_KEY, shuffle).catch(err => {
      console.error('Failed storing shuffle preference', err);
    });
  });

  loopBtn.addEventListener('click', () => {
    loopMode = loopMode === 'all' ? 'one' : loopMode === 'one' ? 'off' : 'all';
    setLoopLabel();
    putStoreValue(LOOP_KEY, loopMode).catch(err => {
      console.error('Failed storing loop preference', err);
    });
  });

  // Volume control
  if (volumeSlider) {
    volumeSlider.addEventListener('input', () => {
      setVolume(Number(volumeSlider.value));
    });
  }

  // Audio timing UI
  audio.addEventListener('loadedmetadata', () => {
    tTot.textContent = fmtTime(audio.duration);
    updateMediaSessionPositionState();
  });
  audio.addEventListener('play', () => {
    maybeAnnounceCurrentTrack();
    startVisualizer();
    updateMediaSessionPlaybackState('playing');
  });
  audio.addEventListener('pause', () => {
    stopVisualizer({ state: 'paused' });
    updateMediaSessionPlaybackState('paused');
  });
  audio.addEventListener('timeupdate', () => {
    if (!isFinite(audio.duration) || audio.duration <= 0) return;
    const pos = Math.round((audio.currentTime / audio.duration) * 1000);
    seek.value = String(pos);
    tCur.textContent = fmtTime(audio.currentTime);
  });
  seek.addEventListener('input', () => {
    if (!isFinite(audio.duration) || audio.duration <= 0) return;
    const pos = Number(seek.value) / 1000;
    audio.currentTime = audio.duration * pos;
    updateMediaSessionPositionState();
  });

  // Track end behavior
  audio.addEventListener('ended', () => {
    stopVisualizer({ clear: true, state: 'idle' });
    // If loop one is set, audio.loop handles it.
    if (loopMode === 'one') return;
    // Loop all or off:
    if (shuffle || loopMode === 'all') {
      playIndex(nextIndex(), {autoplay:true});
    } else {
      // Off: if not last, go next; if last, stop at end.
      if (current < tracks.length - 1) playIndex(current + 1, {autoplay:true});
      else { playPauseBtn.textContent = '▶️ Play'; }
    }
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    // Skip if typing in input fields or textareas
    if (['INPUT','TEXTAREA'].includes(e.target.tagName)) return;
    
    // Skip if select element is focused (for visualizer dropdown)
    if (e.target.tagName === 'SELECT') return;
    
    // Get playlist element and check if it's scrollable (for arrow key checks)
    const list = document.getElementById('list');
    const isListFocused = list && (list === e.target || list.contains(e.target));
    const isListHScrollable = list && list.scrollWidth > list.clientWidth;
    const isListVScrollable = list && list.scrollHeight > list.clientHeight;
    
    if (e.code === 'Space') { 
      e.preventDefault(); 
      playPauseBtn.click(); 
    }
    else if (e.key === 'ArrowRight') {
      // Check for Cmd (Mac) or Ctrl (Windows/Linux) modifier
      if (e.metaKey || e.ctrlKey) {
        // Cmd/Ctrl + Right → next track
        e.preventDefault();
        nextBtn.click();
      } else {
        // Plain Right → seek forward 5 seconds
        // Only prevent default if not focused on a horizontally scrollable playlist
        if (!(isListFocused && isListHScrollable)) {
          e.preventDefault();
          seekBy(SEEK_STEP);
        }
      }
    }
    else if (e.key === 'ArrowLeft') {
      // Check for Cmd (Mac) or Ctrl (Windows/Linux) modifier
      if (e.metaKey || e.ctrlKey) {
        // Cmd/Ctrl + Left → previous track
        e.preventDefault();
        prevBtn.click();
      } else {
        // Plain Left → seek backward 5 seconds
        // Only prevent default if not focused on a horizontally scrollable playlist
        if (!(isListFocused && isListHScrollable)) {
          e.preventDefault();
          seekBy(-SEEK_STEP);
        }
      }
    }
    else if (e.key === 'ArrowUp') {
      // Only prevent default if not focused on a vertically scrollable playlist
      if (!(isListFocused && isListVScrollable)) {
        e.preventDefault();
        adjustVolume(VOLUME_STEP);
      }
    }
    else if (e.key === 'ArrowDown') {
      // Only prevent default if not focused on a vertically scrollable playlist
      if (!(isListFocused && isListVScrollable)) {
        e.preventDefault();
        adjustVolume(-VOLUME_STEP);
      }
    }
    else if (e.key.toLowerCase() === 's') shuffleBtn.click();
    else if (e.key.toLowerCase() === 'l') loopBtn.click();
    else if (e.key.toLowerCase() === 'a' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName) && announceBtn && !announceBtn.disabled) {
      e.preventDefault();
      announceBtn.click();
    }
  });

  // Clean up object URLs when leaving
  window.addEventListener('beforeunload', revokeAll);

  // Restore previous folder if permission remains granted
  (async () => {
    const last = await loadLastHandle();
    if (!last) return;
    try {
      const perm = await last.queryPermission({ mode: 'read' });
      if (perm === 'granted') {
        await scanFolder(last);
      }
    } catch (err) {
      console.error('Unable to restore previous folder', err);
      setFolderPath(null);
    }
  })();
})();
</script>
</body>
</html>
